---
description: Common utility functions and helper patterns across Go and PHP projects for reusable functionality
globs: **/*.{go,php}
alwaysApply: true
---

# Utility Patterns

This rule defines common utility functions and helper patterns used across our Go and PHP projects to promote code reusability and consistency.

## üõ†Ô∏è Common Helper Functions

### **1. String Utilities**

#### Go Pattern

```go
// ‚úÖ Preferred: Utility functions for string operations
package utils

import (
    "crypto/rand"
    "encoding/hex"
    "regexp"
    "strings"
    "unicode"
)

// GenerateRandomString generates a random string of given length
func GenerateRandomString(length int) (string, error) {
    bytes := make([]byte, length/2)
    if _, err := rand.Read(bytes); err != nil {
        return "", err
    }
    return hex.EncodeToString(bytes)[:length], nil
}

// SanitizeString removes potentially dangerous characters
func SanitizeString(input string) string {
    // Remove null bytes and control characters
    input = strings.Map(func(r rune) rune {
        if r == 0 || unicode.IsControl(r) {
            return -1
        }
        return r
    }, input)

    // Trim whitespace
    return strings.TrimSpace(input)
}

// Slugify converts a string to URL-friendly slug
func Slugify(text string) string {
    // Convert to lowercase
    text = strings.ToLower(text)

    // Replace spaces with hyphens
    text = strings.ReplaceAll(text, " ", "-")

    // Remove special characters
    reg := regexp.MustCompile(`[^a-z0-9\-]+`)
    text = reg.ReplaceAllString(text, "")

    // Remove multiple consecutive hyphens
    reg = regexp.MustCompile(`-+`)
    text = reg.ReplaceAllString(text, "-")

    // Trim hyphens from start and end
    text = strings.Trim(text, "-")

    return text
}

// TruncateString truncates string to max length with ellipsis
func TruncateString(text string, maxLength int) string {
    if len(text) <= maxLength {
        return text
    }
    return text[:maxLength-3] + "..."
}
```

#### PHP Pattern

```php
// ‚úÖ Preferred: PHP helper functions for string operations
class StringHelper {

    // Generate random string
    public static function generate_random_string($length = 16) {
        return bin2hex(random_bytes($length / 2));
    }

    // Sanitize string
    public static function sanitize($string) {
        // Remove null bytes and control characters
        $string = preg_replace('/[\x00-\x1F\x7F]/u', '', $string);

        // Trim whitespace
        return trim($string);
    }

    // Create URL slug
    public static function slugify($text) {
        // Convert to lowercase
        $text = strtolower($text);

        // Replace spaces with hyphens
        $text = str_replace(' ', '-', $text);

        // Remove special characters
        $text = preg_replace('/[^a-z0-9\-]/', '', $text);

        // Remove multiple consecutive hyphens
        $text = preg_replace('/-+/', '-', $text);

        // Trim hyphens from start and end
        return trim($text, '-');
    }

    // Truncate string with ellipsis
    public static function truncate($text, $max_length) {
        if (strlen($text) <= $max_length) {
            return $text;
        }
        return substr($text, 0, $max_length - 3) . '...';
    }
}
```

### **2. Date & Time Utilities**

#### Go Pattern

```go
// ‚úÖ Preferred: Time utility functions
package utils

import (
    "time"
    "fmt"
)

// FormatDate formats time to readable string
func FormatDate(t time.Time, format string) string {
    switch format {
    case "short":
        return t.Format("Jan 2, 2006")
    case "long":
        return t.Format("Monday, January 2, 2006")
    case "datetime":
        return t.Format("Jan 2, 2006 at 3:04 PM")
    default:
        return t.Format("2006-01-02")
    }
}

// IsWeekend checks if given time is weekend
func IsWeekend(t time.Time) bool {
    weekday := t.Weekday()
    return weekday == time.Saturday || weekday == time.Sunday
}

// GetStartOfDay returns start of day (00:00:00)
func GetStartOfDay(t time.Time) time.Time {
    year, month, day := t.Date()
    return time.Date(year, month, day, 0, 0, 0, 0, t.Location())
}

// GetEndOfDay returns end of day (23:59:59)
func GetEndOfDay(t time.Time) time.Time {
    year, month, day := t.Date()
    return time.Date(year, month, day, 23, 59, 59, 999999999, t.Location())
}

// TimeAgo returns human-readable time difference
func TimeAgo(t time.Time) string {
    now := time.Now()
    diff := now.Sub(t)

    switch {
    case diff < time.Minute:
        return "just now"
    case diff < time.Hour:
        return fmt.Sprintf("%d minutes ago", int(diff.Minutes()))
    case diff < 24*time.Hour:
        return fmt.Sprintf("%d hours ago", int(diff.Hours()))
    case diff < 30*24*time.Hour:
        return fmt.Sprintf("%d days ago", int(diff.Hours()/24))
    default:
        return t.Format("Jan 2, 2006")
    }
}
```

#### PHP Pattern

```php
// ‚úÖ Preferred: PHP date/time helper functions
class DateHelper {

    // Format date
    public static function format_date($date, $format = 'Y-m-d') {
        $timestamp = is_string($date) ? strtotime($date) : $date;
        return date($format, $timestamp);
    }

    // Check if weekend
    public static function is_weekend($date = null) {
        $date = $date ?: date('Y-m-d');
        $timestamp = is_string($date) ? strtotime($date) : $date;
        $day_of_week = date('N', $timestamp); // 1 = Monday, 7 = Sunday
        return $day_of_week >= 6; // 6 = Saturday, 7 = Sunday
    }

    // Get start of day
    public static function start_of_day($date = null) {
        $date = $date ?: date('Y-m-d');
        return strtotime($date . ' 00:00:00');
    }

    // Get end of day
    public static function end_of_day($date = null) {
        $date = $date ?: date('Y-m-d');
        return strtotime($date . ' 23:59:59');
    }

    // Human readable time ago
    public static function time_ago($datetime) {
        $now = time();
        $timestamp = is_string($datetime) ? strtotime($datetime) : $datetime;
        $diff = $now - $timestamp;

        switch (true) {
            case $diff < 60:
                return 'just now';
            case $diff < 3600:
                return floor($diff / 60) . ' minutes ago';
            case $diff < 86400:
                return floor($diff / 3600) . ' hours ago';
            case $diff < 2592000:
                return floor($diff / 86400) . ' days ago';
            default:
                return date('M j, Y', $timestamp);
        }
    }
}
```

### **3. Validation Utilities**

#### Go Pattern

```go
// ‚úÖ Preferred: Validation helper functions
package utils

import (
    "net"
    "net/mail"
    "regexp"
    "strings"
)

// IsValidEmail validates email format
func IsValidEmail(email string) bool {
    if email == "" {
        return false
    }

    // Basic email validation
    _, err := mail.ParseAddress(email)
    return err == nil
}

// IsValidPhone validates phone number format
func IsValidPhone(phone string) bool {
    if phone == "" {
        return false
    }

    // Remove all non-digit characters except + and spaces
    reg := regexp.MustCompile(`[^\d+\s]`)
    cleaned := reg.ReplaceAllString(phone, "")

    // Basic phone validation (10-15 digits)
    reg = regexp.MustCompile(`^\+?\d{10,15}$`)
    return reg.MatchString(cleaned)
}

// IsValidURL validates URL format
func IsValidURL(url string) bool {
    if url == "" {
        return false
    }

    // Add https:// if missing
    if !strings.HasPrefix(url, "http://") && !strings.HasPrefix(url, "https://") {
        url = "https://" + url
    }

    // Parse URL
    u, err := netUrl.Parse(url)
    return err == nil && u.Scheme != "" && u.Host != ""
}

// ValidatePassword validates password strength
func ValidatePassword(password string) []string {
    var errors []string

    if len(password) < 8 {
        errors = append(errors, "password must be at least 8 characters")
    }

    if !regexp.MustCompile(`[a-z]`).MatchString(password) {
        errors = append(errors, "password must contain at least one lowercase letter")
    }

    if !regexp.MustCompile(`[A-Z]`).MatchString(password) {
        errors = append(errors, "password must contain at least one uppercase letter")
    }

    if !regexp.MustCompile(`\d`).MatchString(password) {
        errors = append(errors, "password must contain at least one number")
    }

    if !regexp.MustCompile(`[!@#$%^&*(),.?":{}|<>]`).MatchString(password) {
        errors = append(errors, "password must contain at least one special character")
    }

    return errors
}
```

#### PHP Pattern

```php
// ‚úÖ Preferred: PHP validation helper functions
class ValidationHelper {

    // Validate email
    public static function is_valid_email($email) {
        if (empty($email)) {
            return false;
        }
        return filter_var($email, FILTER_VALIDATE_EMAIL) !== false;
    }

    // Validate phone number
    public static function is_valid_phone($phone) {
        if (empty($phone)) {
            return false;
        }

        // Remove all non-digit characters except + and spaces
        $cleaned = preg_replace('/[^\d+\s]/', '', $phone);

        // Basic phone validation (10-15 digits)
        return preg_match('/^\+?\d{10,15}$/', $cleaned);
    }

    // Validate URL
    public static function is_valid_url($url) {
        if (empty($url)) {
            return false;
        }

        // Add https:// if missing
        if (!preg_match('/^https?:\/\//', $url)) {
            $url = 'https://' . $url;
        }

        return filter_var($url, FILTER_VALIDATE_URL) !== false;
    }

    // Validate password strength
    public static function validate_password($password) {
        $errors = [];

        if (strlen($password) < 8) {
            $errors[] = 'Password must be at least 8 characters';
        }

        if (!preg_match('/[a-z]/', $password)) {
            $errors[] = 'Password must contain at least one lowercase letter';
        }

        if (!preg_match('/[A-Z]/', $password)) {
            $errors[] = 'Password must contain at least one uppercase letter';
        }

        if (!preg_match('/\d/', $password)) {
            $errors[] = 'Password must contain at least one number';
        }

        if (!preg_match('/[!@#$%^&*(),.?":{}|<>]/', $password)) {
            $errors[] = 'Password must contain at least one special character';
        }

        return $errors;
    }
}
```

### **4. File & Path Utilities**

#### Go Pattern

```go
// ‚úÖ Preferred: File and path utility functions
package utils

import (
    "io/ioutil"
    "mime"
    "os"
    "path/filepath"
    "strings"
)

// GetFileExtension returns file extension without dot
func GetFileExtension(filename string) string {
    return strings.ToLower(strings.TrimPrefix(filepath.Ext(filename), "."))
}

// IsImageFile checks if file is an image
func IsImageFile(filename string) bool {
    ext := GetFileExtension(filename)
    imageExts := map[string]bool{
        "jpg": true, "jpeg": true, "png": true, "gif": true,
        "bmp": true, "webp": true, "svg": true,
    }
    return imageExts[ext]
}

// GetMIMEType returns MIME type for file
func GetMIMEType(filename string) string {
    ext := GetFileExtension(filename)
    return mime.TypeByExtension("." + ext)
}

// SanitizeFilename removes dangerous characters from filename
func SanitizeFilename(filename string) string {
    // Replace dangerous characters
    dangerous := []string{"/", "\\", "..", "<", ">", ":", "*", "?", "\"", "|"}
    safeName := filename

    for _, char := range dangerous {
        safeName = strings.ReplaceAll(safeName, char, "_")
    }

    // Remove multiple underscores
    for strings.Contains(safeName, "__") {
        safeName = strings.ReplaceAll(safeName, "__", "_")
    }

    // Trim underscores from start and end
    safeName = strings.Trim(safeName, "_")

    return safeName
}

// EnsureDir creates directory if it doesn't exist
func EnsureDir(dirPath string) error {
    if _, err := os.Stat(dirPath); os.IsNotExist(err) {
        return os.MkdirAll(dirPath, 0755)
    }
    return nil
}

// GetFileSize returns human-readable file size
func GetFileSize(bytes int64) string {
    const unit = 1024
    if bytes < unit {
        return fmt.Sprintf("%d B", bytes)
    }
    div, exp := int64(unit), 0
    for n := bytes / unit; n >= unit; n /= unit {
        div *= unit
        exp++
    }
    return fmt.Sprintf("%.1f %cB", float64(bytes)/float64(div), "KMGTPE"[exp])
}
```

#### PHP Pattern

```php
// ‚úÖ Preferred: PHP file and path helper functions
class FileHelper {

    // Get file extension
    public static function get_extension($filename) {
        return strtolower(pathinfo($filename, PATHINFO_EXTENSION));
    }

    // Check if image file
    public static function is_image($filename) {
        $ext = self::get_extension($filename);
        $image_extensions = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'svg'];
        return in_array($ext, $image_extensions);
    }

    // Get MIME type
    public static function get_mime_type($filename) {
        $ext = self::get_extension($filename);
        $mime_types = [
            'jpg' => 'image/jpeg',
            'jpeg' => 'image/jpeg',
            'png' => 'image/png',
            'gif' => 'image/gif',
            'pdf' => 'application/pdf',
            'txt' => 'text/plain'
        ];
        return $mime_types[$ext] ?? 'application/octet-stream';
    }

    // Sanitize filename
    public static function sanitize($filename) {
        $dangerous_chars = ['/', '\\', '..', '<', '>', ':', '*', '?', '"', '|'];
        $safe_name = str_replace($dangerous_chars, '_', $filename);

        // Remove multiple underscores
        while (strpos($safe_name, '__') !== false) {
            $safe_name = str_replace('__', '_', $safe_name);
        }

        // Trim underscores from start and end
        return trim($safe_name, '_');
    }

    // Ensure directory exists
    public static function ensure_dir($dir_path) {
        if (!is_dir($dir_path)) {
            mkdir($dir_path, 0755, true);
        }
    }

    // Get human readable file size
    public static function human_readable_size($bytes) {
        $units = ['B', 'KB', 'MB', 'GB', 'TB', 'PB'];
        $bytes = max($bytes, 0);
        $pow = floor(($bytes ? log($bytes) : 0) / log(1024));
        $pow = min($pow, count($units) - 1);
        $bytes /= pow(1024, $pow);
        return round($bytes, 1) . ' ' . $units[$pow];
    }
}
```

### **5. Array/Slice Utilities**

#### Go Pattern

```go
// ‚úÖ Preferred: Slice utility functions
package utils

// ContainsString checks if slice contains string
func ContainsString(slice []string, item string) bool {
    for _, s := range slice {
        if s == item {
            return true
        }
    }
    return false
}

// RemoveDuplicates removes duplicate strings from slice
func RemoveDuplicates(slice []string) []string {
    keys := make(map[string]bool)
    var result []string

    for _, item := range slice {
        if !keys[item] {
            keys[item] = true
            result = append(result, item)
        }
    }

    return result
}

// FilterStrings filters slice based on predicate
func FilterStrings(slice []string, predicate func(string) bool) []string {
    var result []string
    for _, item := range slice {
        if predicate(item) {
            result = append(result, item)
        }
    }
    return result
}

// ChunkSlice splits slice into chunks of given size
func ChunkSlice(slice []string, chunkSize int) [][]string {
    var chunks [][]string

    for i := 0; i < len(slice); i += chunkSize {
        end := i + chunkSize
        if end > len(slice) {
            end = len(slice)
        }
        chunks = append(chunks, slice[i:end])
    }

    return chunks
}
```

#### PHP Pattern

```php
// ‚úÖ Preferred: PHP array helper functions
class ArrayHelper {

    // Check if array contains value
    public static function contains($array, $value) {
        return in_array($value, $array);
    }

    // Remove duplicates
    public static function remove_duplicates($array) {
        return array_unique($array);
    }

    // Filter array
    public static function filter($array, $callback) {
        return array_filter($array, $callback);
    }

    // Chunk array
    public static function chunk($array, $size) {
        return array_chunk($array, $size);
    }

    // Group array by key
    public static function group_by($array, $key) {
        $result = [];
        foreach ($array as $item) {
            $group_key = is_array($item) ? $item[$key] : $item->$key;
            if (!isset($result[$group_key])) {
                $result[$group_key] = [];
            }
            $result[$group_key][] = $item;
        }
        return $result;
    }

    // Find item by property
    public static function find_by($array, $property, $value) {
        foreach ($array as $item) {
            if ((is_array($item) && $item[$property] == $value) ||
                (is_object($item) && $item->$property == $value)) {
                return $item;
            }
        }
        return null;
    }
}
```

## üîß Reusable Components

### **1. Response Helpers**

#### Go Pattern

```go
// ‚úÖ Preferred: Standardized API responses
type APIResponse struct {
    Success bool        `json:"success"`
    Data    interface{} `json:"data,omitempty"`
    Error   string      `json:"error,omitempty"`
    Meta    interface{} `json:"meta,omitempty"`
}

func SuccessResponse(data interface{}) APIResponse {
    return APIResponse{
        Success: true,
        Data:    data,
    }
}

func ErrorResponse(err string) APIResponse {
    return APIResponse{
        Success: false,
        Error:   err,
    }
}

func SuccessWithMeta(data interface{}, meta interface{}) APIResponse {
    return APIResponse{
        Success: true,
        Data:    data,
        Meta:    meta,
    }
}
```

#### PHP Pattern

```php
// ‚úÖ Preferred: Standardized API responses
class ResponseHelper {

    public static function success($data = null, $meta = null) {
        return [
            'success' => true,
            'data' => $data,
            'meta' => $meta
        ];
    }

    public static function error($message, $code = 400) {
        http_response_code($code);
        return [
            'success' => false,
            'error' => $message
        ];
    }

    public static function json($data, $code = 200) {
        http_response_code($code);
        header('Content-Type: application/json');
        return json_encode($data);
    }
}
```

### **2. Pagination Helpers**

#### Go Pattern

```go
// ‚úÖ Preferred: Pagination utility
type Pagination struct {
    Page    int `json:"page"`
    Limit   int `json:"limit"`
    Offset  int `json:"offset"`
    Total   int `json:"total"`
    Pages   int `json:"pages"`
}

type PaginatedResponse struct {
    Data       interface{}  `json:"data"`
    Pagination Pagination   `json:"pagination"`
}

func NewPagination(page, limit int) Pagination {
    if page < 1 {
        page = 1
    }
    if limit < 1 || limit > 100 {
        limit = 10
    }

    offset := (page - 1) * limit

    return Pagination{
        Page:   page,
        Limit:  limit,
        Offset: offset,
    }
}

func (p *Pagination) SetTotal(total int) {
    p.Total = total
    p.Pages = (total + p.Limit - 1) / p.Limit
}

func PaginatedResponse(data interface{}, pagination Pagination) PaginatedResponse {
    return PaginatedResponse{
        Data:       data,
        Pagination: pagination,
    }
}
```

#### PHP Pattern

```php
// ‚úÖ Preferred: Pagination helper
class PaginationHelper {

    public static function calculate($page = 1, $limit = 10) {
        $page = max(1, (int)$page);
        $limit = max(1, min(100, (int)$limit));
        $offset = ($page - 1) * $limit;

        return [
            'page' => $page,
            'limit' => $limit,
            'offset' => $offset
        ];
    }

    public static function meta($pagination, $total) {
        return [
            'page' => $pagination['page'],
            'limit' => $pagination['limit'],
            'offset' => $pagination['offset'],
            'total' => $total,
            'pages' => ceil($total / $pagination['limit'])
        ];
    }

    public static function paginate($data, $pagination, $total) {
        return [
            'data' => $data,
            'pagination' => self::meta($pagination, $total)
        ];
    }
}
```

These utility patterns ensure consistent, reusable functionality across all our Go and PHP projects, promoting code quality and maintainability.
