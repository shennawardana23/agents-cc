---
description: User-specific PHP programming preferences, conventions, and personal coding standards for modern PHP development
globs: **/*.php
alwaysApply: false
---

# User PHP Rules - Personal Preferences

These are personal PHP development preferences and conventions that reflect my coding style and project-specific requirements for PHP applications. These rules complement general PHP best practices while providing specific patterns and preferences for my development workflow.

## 🎯 Personal PHP Philosophy

### **"Modern, Clean, and Scalable"**

I prioritize PHP code that is:

- **Modern** - Using latest PHP features and best practices
- **Clean** - Readable, maintainable, and well-structured
- **Scalable** - Designed for growth and performance
- **Secure** - Built with security as a first-class concern

## 📋 Project Structure Preferences

### **Modern PHP Application Structure**

```php
src/
├── Application/
│   ├── Commands/        # Console commands
│   ├── Controllers/     # HTTP controllers
│   └── Services/        # Application services
├── Domain/
│   ├── Entities/        # Business entities
│   ├── Events/          # Domain events
│   ├── Exceptions/      # Domain exceptions
│   ├── Repositories/    # Repository interfaces
│   └── ValueObjects/    # Value objects
├── Infrastructure/
│   ├── Database/
│   ├── Cache/
│   ├── Logging/
│   └── ExternalServices/
├── Presentation/
│   ├── Http/
│   └── Console/
├── Shared/
│   ├── Kernel/          # Application kernel
│   └── Utils/           # Shared utilities
config/
├── database.php
├── cache.php
├── logging.php
└── services.php
public/
├── index.php
└── assets/
tests/
└── Unit/
└── Integration/
```

### **Laravel-Style Organization**

```php
app/
├── Console/
│   └── Commands/
├── Http/
│   ├── Controllers/
│   ├── Middleware/
│   └── Requests/
├── Models/
├── Services/
├── Repositories/
├── Events/
├── Listeners/
├── Notifications/
├── Mail/
└── Rules/
```

## 🏗️ Naming Conventions

### **Personal PHP Preferences**

```php
<?php

// ✅ Preferred: Modern PHP syntax
declare(strict_types=1);

namespace App\Services;

use App\Repositories\UserRepository;
use Illuminate\Support\Collection;
use Psr\Log\LoggerInterface;

// ✅ Preferred: Clear, descriptive names
final class UserService
{
    private UserRepository $userRepository;
    private LoggerInterface $logger;

    public function __construct(
        UserRepository $userRepository,
        LoggerInterface $logger
    ) {
        $this->userRepository = $userRepository;
        $this->logger = $logger;
    }

    public function createUser(array $data): User
    {
        $this->validateUserData($data);

        try {
            $user = $this->userRepository->create($data);
            $this->logger->info('User created successfully', ['user_id' => $user->id]);

            return $user;
        } catch (Exception $e) {
            $this->logger->error('Failed to create user', [
                'error' => $e->getMessage(),
                'data' => $data
            ]);

            throw new UserCreationException('Unable to create user', 0, $e);
        }
    }
}
```

### **Method Naming**

```php
<?php

// ✅ Preferred: Clear action-oriented names
public function processOrder(Order $order): void
public function calculateTotalPrice(array $items): float
public function sendWelcomeEmail(User $user): bool
public function validateUserInput(array $data): array

// ❌ Avoid: Generic or unclear names
public function doSomething(): void
public function handle(): void
public function process(): void
```

## 🔧 Modern PHP Patterns

### **Constructor Property Promotion**

```php
<?php

// ✅ Preferred: Modern PHP 8+ syntax
final class UserService
{
    public function __construct(
        private UserRepository $userRepository,
        private LoggerInterface $logger,
        private EventDispatcher $eventDispatcher
    ) {}

    public function createUser(CreateUserRequest $request): User
    {
        $this->validateRequest($request);

        $user = $this->userRepository->create($request->toArray());

        $this->eventDispatcher->dispatch(
            new UserCreatedEvent($user)
        );

        return $user;
    }
}
```

### **Value Objects**

```php
<?php

// ✅ Preferred: Immutable value objects
final class Email
{
    private string $value;

    public function __construct(string $value)
    {
        if (!filter_var($value, FILTER_VALIDATE_EMAIL)) {
            throw new InvalidEmailException('Invalid email format');
        }

        $this->value = $value;
    }

    public function getValue(): string
    {
        return $this->value;
    }

    public function getDomain(): string
    {
        return substr(strrchr($this->value, '@'), 1);
    }

    public function equals(Email $other): bool
    {
        return $this->value === $other->value;
    }
}
```

### **Repository Pattern**

```php
<?php

// ✅ Preferred: Clean repository pattern
interface UserRepository
{
    public function findById(int $id): ?User;
    public function findByEmail(string $email): ?User;
    public function save(User $user): void;
    public function delete(int $id): void;
    public function findActiveUsers(): Collection;
}

final class DatabaseUserRepository implements UserRepository
{
    public function __construct(
        private Connection $database,
        private EventDispatcher $events
    ) {}

    public function findById(int $id): ?User
    {
        $sql = 'SELECT * FROM users WHERE id = :id AND deleted_at IS NULL';

        $statement = $this->database->prepare($sql);
        $statement->execute([':id' => $id]);

        $row = $statement->fetch(PDO::FETCH_ASSOC);

        return $row ? User::fromArray($row) : null;
    }
}
```

## 🧪 Testing Standards

### **PHPUnit Tests**

```php
<?php

// ✅ Preferred: Comprehensive PHPUnit tests
use PHPUnit\Framework\TestCase;

final class UserServiceTest extends TestCase
{
    private UserService $userService;
    private UserRepository&MockObject $userRepository;
    private LoggerInterface&MockObject $logger;

    protected function setUp(): void
    {
        $this->userRepository = $this->createMock(UserRepository::class);
        $this->logger = $this->createMock(LoggerInterface::class);

        $this->userService = new UserService(
            $this->userRepository,
            $this->logger
        );
    }

    public function testCreatesUserSuccessfully(): void
    {
        $userData = [
            'name' => 'John Doe',
            'email' => 'john@example.com',
            'password' => 'secret123'
        ];

        $expectedUser = new User(1, 'John Doe', 'john@example.com');

        $this->userRepository
            ->expects($this->once())
            ->method('create')
            ->with($userData)
            ->willReturn($expectedUser);

        $this->logger
            ->expects($this->once())
            ->method('info')
            ->with('User created successfully', ['user_id' => 1]);

        $user = $this->userService->createUser($userData);

        $this->assertEquals($expectedUser, $user);
    }

    public function testThrowsExceptionOnInvalidData(): void
    {
        $invalidData = ['name' => '', 'email' => 'invalid'];

        $this->expectException(ValidationException::class);
        $this->expectExceptionMessage('Invalid user data');

        $this->userService->createUser($invalidData);
    }
}
```

### **Feature Tests**

```php
<?php

// ✅ Preferred: Laravel-style feature tests
use Tests\TestCase;
use Illuminate\Foundation\Testing\RefreshDatabase;

final class UserRegistrationTest extends TestCase
{
    use RefreshDatabase;

    public function testUserCanRegisterSuccessfully(): void
    {
        $userData = [
            'name' => 'John Doe',
            'email' => 'john@example.com',
            'password' => 'password123',
            'password_confirmation' => 'password123'
        ];

        $response = $this->postJson('/api/register', $userData);

        $response->assertStatus(201)
                ->assertJsonStructure([
                    'user' => ['id', 'name', 'email'],
                    'token'
                ]);

        $this->assertDatabaseHas('users', [
            'name' => 'John Doe',
            'email' => 'john@example.com'
        ]);
    }

    public function testRegistrationFailsWithInvalidData(): void
    {
        $invalidData = [
            'name' => '',
            'email' => 'invalid-email',
            'password' => '123'
        ];

        $response = $this->postJson('/api/register', $invalidData);

        $response->assertStatus(422)
                ->assertJsonValidationErrors(['name', 'email', 'password']);
    }
}
```

## ⚡ Performance Patterns

### **Caching Strategy**

```php
<?php

// ✅ Preferred: Multi-layer caching
final class UserCacheService
{
    public function __construct(
        private CacheInterface $cache,
        private UserRepository $repository,
        private LoggerInterface $logger
    ) {}

    public function getUser(int $id): ?User
    {
        $cacheKey = "user:{$id}";

        // Try cache first
        if ($this->cache->has($cacheKey)) {
            $userData = $this->cache->get($cacheKey);

            return $this->hydrateUser($userData);
        }

        // Fetch from database
        $user = $this->repository->findById($id);

        if ($user === null) {
            return null;
        }

        // Cache for 1 hour
        $this->cache->set(
            $cacheKey,
            $this->dehydrateUser($user),
            3600
        );

        return $user;
    }

    public function invalidateUser(int $id): void
    {
        $this->cache->delete("user:{$id}");
        $this->logger->info("User cache invalidated", ['user_id' => $id]);
    }
}
```

### **Database Optimization**

```php
<?php

// ✅ Preferred: Optimized queries with proper indexing
final class UserReportRepository
{
    public function getActiveUsersReport(DateTime $from, DateTime $to): array
    {
        $sql = "
            SELECT
                DATE(u.created_at) as registration_date,
                COUNT(*) as user_count,
                COUNT(o.id) as order_count,
                AVG(o.total) as avg_order_value
            FROM users u
            LEFT JOIN orders o ON u.id = o.user_id
                AND o.created_at BETWEEN :from AND :to
            WHERE u.created_at BETWEEN :from AND :to
                AND u.status = 'active'
                AND u.deleted_at IS NULL
            GROUP BY DATE(u.created_at)
            ORDER BY registration_date DESC
        ";

        $statement = $this->connection->prepare($sql);
        $statement->execute([
            ':from' => $from->format('Y-m-d'),
            ':to' => $to->format('Y-m-d')
        ]);

        return $statement->fetchAll(PDO::FETCH_ASSOC);
    }
}
```

## 🔒 Security Best Practices

### **Input Validation & Sanitization**

```php
<?php

// ✅ Preferred: Comprehensive input validation
final class UserInputValidator
{
    public function validateRegistrationData(array $data): array
    {
        $rules = [
            'name' => 'required|string|min:2|max:50',
            'email' => 'required|email:rfc,dns|max:255',
            'password' => 'required|string|min:8|regex:/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/',
            'age' => 'required|integer|min:18|max:120',
            'terms' => 'required|accepted'
        ];

        $validator = new Validator($data, $rules);

        if ($validator->fails()) {
            throw new ValidationException(
                'Invalid input data',
                $validator->errors()
            );
        }

        return $validator->validated();
    }

    public function sanitizeInput(string $input): string
    {
        // Remove null bytes
        $input = str_replace("\0", '', $input);

        // Remove control characters except newlines and tabs
        $input = preg_replace('/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/', '', $input);

        return trim($input);
    }
}
```

### **Authentication & Authorization**

```php
<?php

// ✅ Preferred: Modern authentication with JWT
final class JWTAuthenticator
{
    private string $secret;
    private int $ttl;

    public function __construct(string $secret, int $ttl = 3600)
    {
        $this->secret = $secret;
        $this->ttl = $ttl;
    }

    public function generateToken(array $payload): string
    {
        $header = json_encode(['typ' => 'JWT', 'alg' => 'HS256']);

        $payload['iat'] = time();
        $payload['exp'] = time() + $this->ttl;

        $base64Header = str_replace(['+', '/', '='], ['-', '_', ''], base64_encode($header));
        $base64Payload = str_replace(['+', '/', '='], ['-', '_', ''], base64_encode(json_encode($payload)));

        $signature = hash_hmac('sha256', $base64Header . "." . $base64Payload, $this->secret, true);
        $base64Signature = str_replace(['+', '/', '='], ['-', '_', ''], base64_encode($signature));

        return $base64Header . "." . $base64Payload . "." . $base64Signature;
    }

    public function validateToken(string $token): ?array
    {
        $parts = explode('.', $token);

        if (count($parts) !== 3) {
            return null;
        }

        $header = json_decode(base64_decode($parts[0]), true);
        $payload = json_decode(base64_decode($parts[1]), true);
        $signature = $parts[2];

        // Verify signature
        $expectedSignature = hash_hmac('sha256', $parts[0] . "." . $parts[1], $this->secret, true);
        $expectedSignature = str_replace(['+', '/', '='], ['-', '_', ''], base64_encode($expectedSignature));

        if (!hash_equals($expectedSignature, $signature)) {
            return null;
        }

        // Check expiration
        if ($payload['exp'] < time()) {
            return null;
        }

        return $payload;
    }
}
```

## 📚 Documentation Standards

### **PHPDoc Documentation**

```php
<?php

/**
 * User service handles all user-related business logic.
 *
 * This service provides methods for user management including
 * creation, authentication, profile updates, and account management.
 *
 * @package App\Services
 */
final class UserService
{
    /**
     * Creates a new user account with the provided data.
     *
     * The method performs comprehensive validation and creates
     * all necessary related records (profile, preferences, etc.).
     *
     * @param CreateUserRequest $request Validated user creation request
     * @return User The created user instance
     *
     * @throws ValidationException When input data is invalid
     * @throws UserCreationException When user cannot be created
     * @throws DatabaseException When database operation fails
     *
     * @example
     * ```php
     * $request = new CreateUserRequest([
     *     'name' => 'John Doe',
     *     'email' => 'john@example.com',
     *     'password' => 'securePassword123'
     * ]);
     *
     * $user = $userService->createUser($request);
     * ```
     */
    public function createUser(CreateUserRequest $request): User
    {
        // Implementation
    }
}
```

### **Inline Documentation**

```php
<?php

/**
 * Updates user profile information with validation.
 *
 * This method handles partial updates - only provided fields
 * will be updated. All data is validated before processing.
 *
 * Validation rules:
 * - name: optional, 2-50 characters
 * - email: optional, valid email format
 * - bio: optional, max 500 characters
 * - website: optional, valid URL format
 *
 * @param int $userId User ID to update
 * @param array $data Updated field values
 * @return bool Success status
 */
public function updateProfile(int $userId, array $data): bool
{
    // Remove any fields that aren't allowed to be updated directly
    $allowedFields = ['name', 'email', 'bio', 'website'];
    $data = array_intersect_key($data, array_flip($allowedFields));

    // Validate the data before processing
    $this->validateProfileData($data);

    // Update the user record
    return $this->userRepository->update($userId, $data);
}
```

## 🛠️ Tool Integration Preferences

### **Development Stack**

```php
// Preferred PHP version and tools
// PHP 8.2+
// Composer 2.5+
// PHPUnit 10+
// PHPStan Level 8+
// Psalm for static analysis
// PHP-CS-Fixer for code formatting
```

### **Quality Tools Configuration**

```yaml
# phpstan.neon
includes:
    - vendor/phpstan/phpstan/conf/bleedingEdge.neon

parameters:
    level: 8
    paths:
        - src/
        - tests/
    excludePaths:
        - vendor/
        - tests/fixtures/
```

### **Testing Setup**

```php
<?php

// tests/bootstrap.php
require_once __DIR__ . '/../vendor/autoload.php';

// Set strict error reporting
error_reporting(E_ALL);
ini_set('display_errors', '1');
ini_set('log_errors', '0');

// Set timezone for consistent testing
date_default_timezone_set('UTC');

// Load environment variables for testing
$dotenv = Dotenv\Dotenv::createImmutable(__DIR__ . '/../');
$dotenv->load();
```

## 📊 Code Quality Metrics

### **Target Standards**

- **Cyclomatic Complexity**: ≤ 8 per method
- **Method Length**: ≤ 30 lines
- **Class Size**: ≤ 300 lines
- **Method Parameters**: ≤ 5 parameters
- **Test Coverage**: ≥ 90%

### **Static Analysis**

- **PHPStan Level**: 8 (maximum)
- **Psalm**: Maximum strictness
- **PHP-CS-Fixer**: PSR-12 compliant
- **Deptrac**: Maintain architectural boundaries

## 🚨 Common PHP Pitfalls to Avoid

### **Performance Issues**

- Don't use `count()` in loops without caching
- Don't create objects unnecessarily in hot paths
- Don't use regex for simple string operations
- Don't forget to free database result sets
- Don't use `SELECT *` in production queries

### **Security Issues**

- Don't trust user input without validation
- Don't use deprecated `mysql_` functions
- Don't store passwords without proper hashing
- Don't expose sensitive data in error messages
- Don't use weak random number generators

### **Code Quality Issues**

- Don't use magic numbers or strings
- Don't create methods that do multiple things
- Don't use global variables for state
- Don't ignore return values from functions
- Don't write methods longer than 30 lines

## 🎯 Personal Best Practices

### **Code Organization**

1. **Single Responsibility** - Each class has one clear purpose
2. **Dependency Injection** - Use constructor injection for all dependencies
3. **Interface Segregation** - Keep interfaces focused and small
4. **Composition Over Inheritance** - Prefer composition for flexibility
5. **Domain-Driven Design** - Structure code around business domains

### **Error Handling**

1. **Custom Exceptions** - Create specific exception types
2. **Graceful Degradation** - Handle failures elegantly
3. **Proper Logging** - Log errors with context
4. **User-Friendly Messages** - Show helpful error messages
5. **Rollback Strategies** - Handle transaction rollbacks

### **Performance Optimization**

1. **Database Optimization** - Use proper indexes and queries
2. **Caching Strategy** - Implement multi-layer caching
3. **Lazy Loading** - Load data only when needed
4. **Connection Pooling** - Reuse database connections
5. **Memory Management** - Avoid memory leaks

### **Security Measures**

1. **Input Validation** - Validate and sanitize all inputs
2. **SQL Injection Prevention** - Use prepared statements
3. **XSS Prevention** - Escape output properly
4. **CSRF Protection** - Use anti-CSRF tokens
5. **Secure Headers** - Set appropriate security headers

### **Testing Strategy**

1. **Unit Tests** - Test individual components in isolation
2. **Integration Tests** - Test component interactions
3. **E2E Tests** - Test complete user workflows
4. **Performance Tests** - Measure application performance
5. **Security Tests** - Test for common vulnerabilities

### **Maintainability**

1. **Clear Documentation** - Document all public APIs
2. **Consistent Formatting** - Use automatic code formatters
3. **Descriptive Naming** - Use meaningful names throughout
4. **Modular Design** - Keep code organized and separated
5. **Regular Refactoring** - Continuously improve code quality

---

*"Any fool can write code that a computer can understand. Good programmers write code that humans can understand." - Martin Fowler*

These personal PHP rules reflect my preferred patterns and practices for writing clean, maintainable, and secure PHP code. They emphasize modern PHP features, clean architecture, and robust testing while maintaining high performance and security standards.
