---
description: Go Clean Architecture patterns for scalable, maintainable, and testable application design
globs: **/*.go
alwaysApply: true
---

# Go Clean Architecture Patterns

This rule defines the Clean Architecture patterns used in our Go projects, ensuring maintainable, testable, and scalable code.

## üèóÔ∏è Clean Architecture Principles

### **1. Dependency Rule**

- Source code dependencies can only point inward
- Inner layers are independent of outer layers
- No dependencies from inner layers to outer layers

### **2. Layer Responsibilities**

#### **Entities (Inner Layer)**

- Core business objects of the application
- Encapsulate enterprise-wide business rules
- Independent of any framework or external concerns
- Can be tested in isolation

```go
// ‚úÖ Preferred: Clean entity with business logic
type User struct {
    ID          string    `db:"id"`
    Email       string    `db:"email"`
    FullName    string    `db:"full_name"`
    Status      int64     `db:"status"`
    CreatedDate time.Time `db:"created_date"`
    UpdatedDate time.Time `db:"updated_date"`
}

func (u *User) IsActive() bool {
    return u.Status == 1
}

func (u *User) HasValidEmail() bool {
    return strings.Contains(u.Email, "@")
}

func (u *User) DisplayName() string {
    if u.FullName != "" {
        return u.FullName
    }
    return u.Email
}
```

#### **Use Cases / Services (Middle Layer)**

- Application-specific business rules
- Orchestrate data flow between entities and repositories
- Independent of UI, database, and external concerns
- Contain the core application logic

```go
// ‚úÖ Preferred: Service layer with business rules
type UserService interface {
    CreateUser(ctx context.Context, req CreateUserRequest) (*User, error)
    GetUserByID(ctx context.Context, userID string) (*User, error)
    UpdateUser(ctx context.Context, req UpdateUserRequest) (*User, error)
    DeleteUser(ctx context.Context, userID string) error
}

type userService struct {
    userRepo   repository.UserRepository
    cache      cache.RedisCache
    validator  *validator.Validate
    logger     *logrus.Logger
}

func (s *userService) CreateUser(ctx context.Context, req CreateUserRequest) (*User, error) {
    // Business rule validation
    if err := s.validator.Struct(req); err != nil {
        return nil, fmt.Errorf("invalid request: %w", err)
    }

    // Check business rules
    existingUser, err := s.userRepo.FindByEmail(ctx, req.Email)
    if err == nil && existingUser != nil {
        return nil, fmt.Errorf("user with email %s already exists", req.Email)
    }

    // Create entity
    user := &User{
        ID:          uuid.New().String(),
        Email:       req.Email,
        FullName:    req.FullName,
        Status:      1,
        CreatedDate: time.Now(),
        UpdatedDate: time.Now(),
    }

    // Persist
    if err := s.userRepo.Create(ctx, user); err != nil {
        return nil, fmt.Errorf("failed to create user: %w", err)
    }

    // Cache for performance
    cacheKey := fmt.Sprintf("user:%s", user.ID)
    if err := s.cache.Set(ctx, cacheKey, user, 30*time.Minute); err != nil {
        s.logger.Warnf(ctx, "Failed to cache user: %v", err)
    }

    return user, nil
}
```

#### **Interface Adapters (Outer Layer)**

- Controllers, gateways, presenters
- Convert data between use cases and external layers
- No business logic, only data transformation

```go
// ‚úÖ Preferred: Clean controller layer
type UserController interface {
    CreateUser(c *gin.Context)
    GetUser(c *gin.Context)
    UpdateUser(c *gin.Context)
    DeleteUser(c *gin.Context)
}

type userController struct {
    userService service.UserService
    logger      *logrus.Logger
}

func (ctrl *userController) CreateUser(c *gin.Context) {
    ctx := logger.StartTransaction(c.Request.Context())

    var req CreateUserRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        ctrl.logger.Errorf(ctx, "Invalid request: %v", err)
        c.JSON(http.StatusBadRequest, gin.H{
            "error": "Invalid request format",
        })
        return
    }

    user, err := ctrl.userService.CreateUser(ctx, req)
    if err != nil {
        ctrl.logger.Errorf(ctx, "Failed to create user: %v", err)
        c.JSON(http.StatusInternalServerError, gin.H{
            "error": "Failed to create user",
        })
        return
    }

    c.JSON(http.StatusCreated, gin.H{
        "data": user,
        "message": "User created successfully",
    })
}
```

#### **Repositories (Outer Layer)**

- Data access layer
- Implement interfaces defined by use cases
- Handle database, file system, network calls
- Convert external data to internal format

```go
// ‚úÖ Preferred: Repository with proper error handling
type UserRepository interface {
    Create(ctx context.Context, user *User) error
    FindByID(ctx context.Context, id string) (*User, error)
    FindByEmail(ctx context.Context, email string) (*User, error)
    Update(ctx context.Context, user *User) error
    Delete(ctx context.Context, id string) error
    FindAll(ctx context.Context) ([]*User, error)
}

type userRepository struct {
    db database.DB
}

func (r *userRepository) FindByEmail(ctx context.Context, email string) (*User, error) {
    query := `SELECT id, email, full_name, status, created_date, updated_date
              FROM users WHERE email = $1`

    var user User
    err := r.db.QueryRowContext(ctx, query, email).Scan(
        &user.ID, &user.Email, &user.FullName, &user.Status,
        &user.CreatedDate, &user.UpdatedDate,
    )

    if err != nil {
        if err == sql.ErrNoRows {
            return nil, nil // User not found
        }
        return nil, fmt.Errorf("failed to find user by email: %w", err)
    }

    return &user, nil
}
```

## üîß Implementation Patterns

### **1. Dependency Injection**

#### Constructor Injection

```go
// ‚úÖ Preferred: Constructor injection
type UserService struct {
    userRepo   UserRepository
    cache      cache.RedisCache
    validator  *validator.Validate
    logger     *logrus.Logger
}

func NewUserService(
    userRepo UserRepository,
    cache cache.RedisCache,
    validator *validator.Validate,
    logger *logrus.Logger,
) *UserService {
    return &UserService{
        userRepo:  userRepo,
        cache:     cache,
        validator: validator,
        logger:    logger,
    }
}
```

### **2. Interface Segregation**

#### Small, Focused Interfaces

```go
// ‚úÖ Preferred: Small, focused interfaces
type UserRepository interface {
    Create(ctx context.Context, user *User) error
    FindByID(ctx context.Context, id string) (*User, error)
    FindByEmail(ctx context.Context, email string) (*User, error)
    Update(ctx context.Context, user *User) error
    Delete(ctx context.Context, id string) error
}

type UserCache interface {
    Get(ctx context.Context, key string, dest interface{}) error
    Set(ctx context.Context, key string, value interface{}, ttl time.Duration) error
    Delete(ctx context.Context, key string) error
}
```

### **3. Error Handling**

#### Structured Error Handling

```go
// ‚úÖ Preferred: Structured error handling
var (
    ErrUserNotFound     = errors.New("user not found")
    ErrUserAlreadyExists = errors.New("user already exists")
    ErrInvalidInput     = errors.New("invalid input")
)

func (s *userService) GetUserByID(ctx context.Context, userID string) (*User, error) {
    if userID == "" {
        return nil, fmt.Errorf("%w: user ID is required", ErrInvalidInput)
    }

    // Try cache first
    cacheKey := fmt.Sprintf("user:%s", userID)
    var user User
    if err := s.cache.Get(ctx, cacheKey, &user); err == nil {
        return &user, nil
    }

    // Get from repository
    user, err := s.userRepo.FindByID(ctx, userID)
    if err != nil {
        return nil, fmt.Errorf("failed to get user: %w", err)
    }

    if user == nil {
        return nil, ErrUserNotFound
    }

    // Cache the result
    if err := s.cache.Set(ctx, cacheKey, user, 30*time.Minute); err != nil {
        s.logger.Warnf(ctx, "Failed to cache user: %v", err)
    }

    return user, nil
}
```

### **4. Context Usage**

#### Request-Scoped Context

```go
// ‚úÖ Preferred: Context for timeouts and cancellation
func (s *userService) CreateUser(ctx context.Context, req CreateUserRequest) (*User, error) {
    // Create context with timeout
    ctx, cancel := context.WithTimeout(ctx, 30*time.Second)
    defer cancel()

    // Validate request
    if err := s.validator.Struct(req); err != nil {
        return nil, fmt.Errorf("validation failed: %w", err)
    }

    // Database transaction with context
    tx, err := s.db.BeginTx(ctx, nil)
    if err != nil {
        return nil, fmt.Errorf("failed to start transaction: %w", err)
    }
    defer tx.Rollback()

    // Create user
    user, err := s.createUserInTransaction(ctx, tx, req)
    if err != nil {
        return nil, err
    }

    // Commit transaction
    if err := tx.Commit(); err != nil {
        return nil, fmt.Errorf("failed to commit transaction: %w", err)
    }

    return user, nil
}
```

### **5. Testing Patterns**

#### Unit Test Structure

```go
// ‚úÖ Preferred: Clean unit tests
func TestUserService_CreateUser(t *testing.T) {
    tests := []struct {
        name    string
        req     CreateUserRequest
        wantErr bool
        errType error
    }{
        {
            name: "valid user creation",
            req: CreateUserRequest{
                Email:    "test@example.com",
                FullName: "Test User",
            },
            wantErr: false,
        },
        {
            name: "invalid email",
            req: CreateUserRequest{
                Email:    "invalid-email",
                FullName: "Test User",
            },
            wantErr: true,
            errType: ErrInvalidInput,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Setup mocks
            mockRepo := &mockUserRepository{}
            mockCache := &mockCache{}
            validator := validator.New()

            service := NewUserService(mockRepo, mockCache, validator, logrus.New())

            // Execute
            _, err := service.CreateUser(context.Background(), tt.req)

            // Assert
            if tt.wantErr {
                assert.Error(t, err)
                if tt.errType != nil {
                    assert.True(t, errors.Is(err, tt.errType))
                }
                return
            }
            assert.NoError(t, err)
        })
    }
}
```

## üìÅ Project Structure

### **Standard Go Project Layout**

```
myapp/
‚îú‚îÄ‚îÄ cmd/                    # Application entry points
‚îÇ   ‚îî‚îÄ‚îÄ server/
‚îÇ       ‚îî‚îÄ‚îÄ main.go
‚îú‚îÄ‚îÄ internal/              # Private application code
‚îÇ   ‚îú‚îÄ‚îÄ entity/            # Business entities
‚îÇ   ‚îú‚îÄ‚îÄ service/           # Business logic
‚îÇ   ‚îú‚îÄ‚îÄ repository/        # Data access
‚îÇ   ‚îú‚îÄ‚îÄ controller/        # HTTP handlers
‚îÇ   ‚îú‚îÄ‚îÄ middleware/        # HTTP middleware
‚îÇ   ‚îî‚îÄ‚îÄ util/              # Utility packages
‚îú‚îÄ‚îÄ pkg/                   # Public packages
‚îú‚îÄ‚îÄ api/                   # API definitions
‚îú‚îÄ‚îÄ scripts/               # Build scripts
‚îî‚îÄ‚îÄ tests/                 # Integration tests
```

### **Layer Dependencies**

```
Controllers ‚Üí Services ‚Üí Repositories ‚Üí Entities
     ‚Üì           ‚Üì           ‚Üì
Middleware  Utilities   Database
     ‚Üì           ‚Üì
    HTTP       Cache
```

## üõ†Ô∏è Best Practices

### **1. Interface Design**

- Keep interfaces small and focused
- Use interfaces for dependency injection
- Prefer small interfaces over large ones
- Document all interface methods

### **2. Error Handling**

- Use error wrapping for context
- Define specific error types
- Handle errors at the appropriate layer
- Don't ignore returned errors

### **3. Testing**

- Write unit tests for all business logic
- Mock dependencies for isolation
- Use table-driven tests
- Test error cases and edge cases

### **4. Context Usage**

- Pass context through all layers
- Use context for timeouts
- Store request-scoped data in context
- Cancel long-running operations

### **5. Dependency Injection**

- Use constructor injection
- Keep dependency trees shallow
- Mock dependencies for testing
- Avoid global dependencies

This clean architecture ensures our Go applications are maintainable, testable, and scalable, following SOLID principles and domain-driven design.
